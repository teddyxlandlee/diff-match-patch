<SPAN TITLE="i=0">package net.minecraft.block;&para;<BR>&para;<BR>import com.google.common.collect.ImmutableMap;&para;<BR>import com.mojang.serialization.MapCodec;&para;<BR>import java.util.Arrays;&para;<BR>import java.util.Collections;&para;<BR>import java.util.List;&para;<BR>import java.util.Random;&para;<BR>import java.util.function.Function;&para;<BR>import java.util.function.Predicate;&para;<BR>import java.util.function.ToIntFunction;&para;<BR>import net.</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=347">minecra</INS><SPAN TITLE="i=354">f</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=355">a</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=355">t.</INS><SPAN TITLE="i=357">b</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=358">ri</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=358">lo</INS><SPAN TITLE="i=360">c</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=361">mc</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=361">k</INS><SPAN TITLE="i=362">.</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=363">ap</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=363">ent</INS><SPAN TITLE="i=366">i</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=367">ty</INS><SPAN TITLE="i=369">.</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=370">Block</INS><SPAN TITLE="i=375">En</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=377">vT</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=377">tit</INS><SPAN TITLE="i=380">y</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=381">pe</DEL><SPAN TITLE="i=381">;&para;<BR>import net.</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=394">minecra</INS><SPAN TITLE="i=401">f</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=402">a</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=402">t.</INS><SPAN TITLE="i=404">b</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=405">ri</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=405">lo</INS><SPAN TITLE="i=407">c</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=408">mc</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=408">k</INS><SPAN TITLE="i=409">.</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=410">ap</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=410">ent</INS><SPAN TITLE="i=413">i</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=414">ty</INS><SPAN TITLE="i=416">.</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=417">Block</INS><SPAN TITLE="i=422">En</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=424">v</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=424">tityT</INS><SPAN TITLE="i=429">i</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=430">cke</INS><SPAN TITLE="i=433">r</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=434">;&para;<BR>imp</INS><SPAN TITLE="i=439">o</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=440">rt </INS><SPAN TITLE="i=443">n</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=444">et.</INS><SPAN TITLE="i=447">m</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=448">inecraft.block.</INS><SPAN TITLE="i=463">ent</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=466">ity.BlockEntityType</INS><SPAN TITLE="i=485">;&para;<BR>import net.minecraft.block.piston.PistonBehavior;&para;<BR>import net.minecraft.entity.Entity;&para;<BR>import net.minecraft.entity.EntityType;&para;<BR>import net.minecraft.entity.ai.pathing.NavigationType;&para;<BR>import net.minecraft.entity.player.PlayerEntity;&para;<BR>import net.minecraft.entity.projectile.ProjectileEntity;&para;<BR>import net.minecraft.fluid.Fluid;&para;<BR>import net.minecraft.fluid.FluidState;&para;<BR>import net.minecraft.fluid.Fluids;&para;<BR>import net.minecraft.item.Item;&para;<BR>import net.minecraft.item.ItemPlacementContext;&para;<BR>import net.minecraft.item.ItemStack;&para;<BR>import net.minecraft.loot.LootTable;&para;<BR>import net.minecraft.loot.LootTables;&para;<BR>import net.minecraft.loot.context.LootContext;&para;<BR>import net.minecraft.loot.context.LootContextParameters;&para;<BR>import net.minecraft.loot.context.LootContextTypes;&para;<BR>import net.minecraft.screen.NamedScreenHandlerFactory;&para;<BR>import net.minecraft.server.network.DebugInfoSender;&para;<BR>import net.minecraft.server.world.ServerWorld;&para;<BR>import net.minecraft.sound.BlockSoundGroup;&para;<BR>import net.minecraft.state.State;&para;<BR>import net.minecraft.state.property.Property;&para;<BR>import net.minecraft.tag.FluidTags;&para;<BR>import net.minecraft.tag.Tag;&para;<BR>import net.minecraft.util.ActionResult;&para;<BR>import net.minecraft.util.BlockMirror;&para;<BR>import net.minecraft.util.BlockRotation;&para;<BR>import net.minecraft.util.DyeColor;&para;<BR>import net.minecraft.util.Hand;&para;<BR>import net.minecraft.util.Identifier;&para;<BR>import net.minecraft.util.hit.BlockHitResult;&para;<BR>import net.minecraft.util.math.BlockPos;&para;<BR>import net.minecraft.util.math.Direction;&para;<BR>import net.minecraft.util.math.MathHelper;&para;<BR>import net.minecraft.util.math.Vec3d;&para;<BR>import net.minecraft.util.registry.Registry;&para;<BR>import net.minecraft.util.shape.VoxelShape;&para;<BR>import net.minecraft.util.shape.VoxelShapes;&para;<BR>import net.minecraft.world.BlockView;&para;<BR>import net.minecraft.world.EmptyBlockView;&para;<BR>import net.minecraft.world.World;&para;<BR>import net.minecraft.world.WorldAccess;&para;<BR>import net.minecraft.world.WorldView;&para;<BR>import org.jetbrains.annotations.Nullable;&para;<BR>&para;<BR>public abstract class AbstractBlock {&para;<BR>   protected static final Direction[] </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=2458">FA</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=2458">DIRE</INS><SPAN TITLE="i=2462">C</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=2463">T</INS><SPAN TITLE="i=2464">I</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=2465">O</INS><SPAN TITLE="i=2466">N</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=2467">G</DEL><SPAN TITLE="i=2467">S;&para;<BR>   protected final Material material;&para;<BR>   protected final boolean collidable;&para;<BR>   protected final float resistance;&para;<BR>   protected final boolean randomTicks;&para;<BR>   protected final BlockSoundGroup soundGroup;&para;<BR>   protected final float slipperiness;&para;<BR>   protected final float velocityMultiplier;&para;<BR>   protected final float jumpVelocityMultiplier;&para;<BR>   protected final boolean dynamicBounds;&para;<BR>   protected final AbstractBlock.Settings settings;&para;<BR>   @Nullable&para;<BR>   protected Identifier lootTableId;&para;<BR>&para;<BR>   public AbstractBlock(AbstractBlock.Settings settings) {&para;<BR>      this.material = settings.material;&para;<BR>      this.collidable = settings.collidable;&para;<BR>      this.lootTableId = settings.lootTableId;&para;<BR>      this.resistance = settings.resistance;&para;<BR>      this.randomTicks = settings.randomTicks;&para;<BR>      this.soundGroup = settings.soundGroup;&para;<BR>      this.slipperiness = settings.slipperiness;&para;<BR>      this.velocityMultiplier = settings.velocityMultiplier;&para;<BR>      this.jumpVelocityMultiplier = settings.jumpVelocityMultiplier;&para;<BR>      this.dynamicBounds = settings.dynamicBounds;&para;<BR>      this.settings = settings;&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public void prepare(BlockState state, WorldAccess world, BlockPos pos, int flags, int maxUpdateDepth) {&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public boolean canPathfindThrough(BlockState state, BlockView world, BlockPos pos, NavigationType type) {&para;<BR>      switch(type) {&para;<BR>      case LAND:&para;<BR>         return !state.isFullCube(world, pos);&para;<BR>      case WATER:&para;<BR>         return world.getFluidState(pos).isIn(FluidTags.WATER);&para;<BR>      case AIR:&para;<BR>         return !state.isFullCube(world, pos);&para;<BR>      default:&para;<BR>         return false;&para;<BR>      }&para;<BR>   }&para;<BR>&para;<BR>   </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=4083">@D</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=4083">/**&para;<BR>    * G</INS><SPAN TITLE="i=4094">e</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=4095">ts the </INS><SPAN TITLE="i=4102">p</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=4103">r</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=4103">ossibly updat</INS><SPAN TITLE="i=4116">e</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=4117">d blo</INS><SPAN TITLE="i=4122">c</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=4123">k st</INS><SPAN TITLE="i=4127">ate</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=4130">d&para;<BR></DEL><SPAN TITLE="i=4130"> </SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=4131">of</INS><SPAN TITLE="i=4133"> </SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=4134">this</INS><SPAN TITLE="i=4138"> </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=4139">pu</DEL><SPAN TITLE="i=4139">bl</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=4141">i</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=4141">o</INS><SPAN TITLE="i=4142">c</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=4143">k</INS><SPAN TITLE="i=4144"> </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=4145">B</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=4145">when a neighboring b</INS><SPAN TITLE="i=4165">lock</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=4169">St</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=4169"> is upd</INS><SPAN TITLE="i=4176">ate</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=4179">d.&para;<BR></INS><SPAN TITLE="i=4182"> </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=4183">g</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=4183">   * &para;<BR>    * @r</INS><SPAN TITLE="i=4197">et</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=4199">S</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=4199">urn the new s</INS><SPAN TITLE="i=4212">tate</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=4216">F</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=4216"> </INS><SPAN TITLE="i=4217">o</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=4218">rNe</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=4218">f th</INS><SPAN TITLE="i=4222">i</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=4223">gh</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=4223">s </INS><SPAN TITLE="i=4225">b</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=4226">orUpdate(B</DEL><SPAN TITLE="i=4226">lock</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=4230">S</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=4230">&para;<BR>    * &para;<BR>    * @param s</INS><SPAN TITLE="i=4252">tate </SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=4257">the </INS><SPAN TITLE="i=4261">state</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=4266">,</DEL><SPAN TITLE="i=4266"> </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=4267">D</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=4267">of this block&para;<BR>    * @param d</INS><SPAN TITLE="i=4295">irection </SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=4304">the </INS><SPAN TITLE="i=4308">direction</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=4317">,</DEL><SPAN TITLE="i=4317"> </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=4318">B</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=4318">from this b</INS><SPAN TITLE="i=4329">lock</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=4333"> to the neighbor&para;<BR>    * @param neighbor</INS><SPAN TITLE="i=4371">State </SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=4377">the state of the updated </INS><SPAN TITLE="i=4402">ne</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=4404">ighbor block&para;<BR>    * @param world the </INS><SPAN TITLE="i=4440">w</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=4441">orld&para;<BR>    * @param pos the position of this block&para;<BR>    * @param neighborPos the position of the neighbor block&para;<BR>    */&para;<BR>   @Deprecated&para;<BR>   public BlockState getStateForNeighborUpdate(BlockState state, Direction direction, BlockState neighbor</INS><SPAN TITLE="i=4677">State, WorldAccess world, BlockPos pos, BlockPos </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=4726">p</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=4726">neighb</INS><SPAN TITLE="i=4732">o</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=4733">sF</DEL><SPAN TITLE="i=4733">r</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=4734">P</INS><SPAN TITLE="i=4735">o</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=4736">m</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=4736">s</INS><SPAN TITLE="i=4737">) {&para;<BR>      return state;&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR></SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=4782">   @Environment(EnvType.CLIENT)&para;<BR></DEL><SPAN TITLE="i=4782">   public boolean isSideInvisible(BlockState state, BlockState stateFrom, Direction direction) {&para;<BR>      return false;&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public void neighborUpdate(BlockState state, World world, BlockPos pos, Block block, BlockPos fromPos, boolean notify) {&para;<BR>      DebugInfoSender.sendNeighborUpdate(world, pos);&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public void onBlockAdded(BlockState state, World world, BlockPos pos, BlockState oldState, boolean notify) {&para;<BR>   }&para;<BR>&para;<BR>   /**&para;<BR>    * Called in {@link net.minecraft.world.chunk.WorldChunk#setBlockState(BlockPos, BlockState, boolean)} if {@code newState} is different from {@code state}. Vanilla blocks perform removal cleanups here.&para;<BR>    */&para;<BR>   @Deprecated&para;<BR>   public void onStateReplaced(BlockState state, World world, BlockPos pos, BlockState newState, boolean moved) {&para;<BR>      if (</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=5595">s</INS><SPAN TITLE="i=5596">t</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=5597">his</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=5597">ate</INS><SPAN TITLE="i=5600">.hasBlockEntity() &amp;&amp; !state.isOf(newState.getBlock())) {&para;<BR>         world.removeBlockEntity(pos);&para;<BR>      }&para;<BR>&para;<BR>   }&para;<BR>&para;<BR>   /**&para;<BR>    * Called when this block is used by a player.&para;<BR>    * This, by default, is bound to using the right mouse button.&para;<BR>    * &para;<BR>    * &lt;p&gt;This method is called on both the logical client and logical server, so take caution when overriding this method.&para;<BR>    * The logical side can be checked using {@link net.minecraft.world.World#isClient() world.isClient()}.&para;<BR>    * &para;<BR>    * &lt;p&gt;If the action result is successful on a logical client, then the action will be sent to the logical server for processing.&para;<BR>    * &para;<BR>    * @return an action result that specifies if using the block was successful.&para;<BR>    */&para;<BR>   @Deprecated&para;<BR>   public ActionResult onUse(BlockState state, World world, BlockPos pos, PlayerEntity player, Hand hand, BlockHitResult hit) {&para;<BR>      return ActionResult.PASS;&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public boolean onSyncedBlockEvent(BlockState state, World world, BlockPos pos, int type, int data) {&para;<BR>      return false;&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public BlockRenderType getRenderType(BlockState state) {&para;<BR>      return BlockRenderType.MODEL;&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public boolean hasSidedTransparency(BlockState state) {&para;<BR>      return false;&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public boolean emitsRedstonePower(BlockState state) {&para;<BR>      return false;&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public PistonBehavior getPistonBehavior(BlockState state) {&para;<BR>      return this.material.getPistonBehavior();&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public FluidState getFluidState(BlockState state) {&para;<BR>      return Fluids.EMPTY.getDefaultState();&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public boolean hasComparatorOutput(BlockState state) {&para;<BR>      return false;&para;<BR>   }&para;<BR>&para;<BR>   public AbstractBlock.OffsetType getOffsetType() {&para;<BR>      return AbstractBlock.OffsetType.NONE;&para;<BR>   }&para;<BR>&para;<BR></SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=7401">   public float getMaxModelOffset() {&para;<BR>      return 0.25F;&para;<BR>   }&para;<BR>&para;<BR></INS><SPAN TITLE="i=7465">   /**&para;<BR>    * Applies a block rotation to a block state.&para;<BR>    * &para;<BR>    * &lt;p&gt;By default, this returns the provided block state.&para;<BR>    * &para;<BR>    * @return the rotated block state&para;<BR>    */&para;<BR>   @Deprecated&para;<BR>   public BlockState rotate(BlockState state, BlockRotation rotation) {&para;<BR>      return state;&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public BlockState mirror(BlockState state, BlockMirror mirror) {&para;<BR>      return state;&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public boolean canReplace(BlockState state, ItemPlacementContext context) {&para;<BR>      return this.material.isReplaceable() &amp;&amp; (context.getStack().isEmpty() || </SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=8035">!</INS><SPAN TITLE="i=8036">context.getStack().</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=8055">getItem</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=8055">isOf</INS><SPAN TITLE="i=8059">(</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=8060">) != </DEL><SPAN TITLE="i=8060">this.asItem(</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=8072">)</INS><SPAN TITLE="i=8073">));&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public boolean canBucketPlace(BlockState state, Fluid fluid) {&para;<BR>      return this.material.isReplaceable() || !this.material.isSolid();&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public List&lt;ItemStack&gt; getDroppedStacks(BlockState state, LootContext.Builder builder) {&para;<BR>      Identifier identifier = this.getLootTableId();&para;<BR>      if (identifier == LootTables.EMPTY) {&para;<BR>         return Collections.emptyList();&para;<BR>      } else {&para;<BR>         LootContext lootContext = builder.parameter(LootContextParameters.BLOCK_STATE, state).build(LootContextTypes.BLOCK);&para;<BR>         ServerWorld serverWorld = lootContext.getWorld();&para;<BR>         LootTable lootTable = serverWorld.getServer().getLootManager().getTable(identifier);&para;<BR>         return lootTable.generateLoot(lootContext);&para;<BR>      }&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR></SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=8863">   @Environment(EnvType.CLIENT)&para;<BR></DEL><SPAN TITLE="i=8863">   public long getRenderingSeed(BlockState state, BlockPos pos) {&para;<BR>      return MathHelper.hashCode(pos);&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public VoxelShape getCullingShape(BlockState state, BlockView world, BlockPos pos) {&para;<BR>      return state.getOutlineShape(world, pos);&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public VoxelShape getSidesShape(BlockState state, BlockView world, BlockPos pos) {&para;<BR>      return this.getCollisionShape(state, world, pos, ShapeContext.absent());&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public VoxelShape getRaycastShape(BlockState state, BlockView world, BlockPos pos) {&para;<BR>      return VoxelShapes.empty();&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public int getOpacity(BlockState state, BlockView world, BlockPos pos) {&para;<BR>      if (state.isOpaqueFullCube(world, pos)) {&para;<BR>         return world.getMaxLightLevel();&para;<BR>      } else {&para;<BR>         return state.isTranslucent(world, pos) ? 0 : 1;&para;<BR>      }&para;<BR>   }&para;<BR>&para;<BR>   @Nullable&para;<BR>   @Deprecated&para;<BR>   public NamedScreenHandlerFactory createScreenHandlerFactory(BlockState state, World world, BlockPos pos) {&para;<BR>      return null;&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public boolean canPlaceAt(BlockState state, WorldView world, BlockPos pos) {&para;<BR>      return true;&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR></SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=10025">   @Environment(EnvType.CLIENT)&para;<BR></DEL><SPAN TITLE="i=10025">   public float getAmbientOcclusionLightLevel(BlockState state, BlockView world, BlockPos pos) {&para;<BR>      return state.isFullCube(world, pos) ? 0.2F : 1.0F;&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public int getComparatorOutput(BlockState state, World world, BlockPos pos) {&para;<BR>      return 0;&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public VoxelShape getOutlineShape(BlockState state, BlockView world, BlockPos pos, ShapeContext context) {&para;<BR>      return VoxelShapes.fullCube();&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public VoxelShape getCollisionShape(BlockState state, BlockView world, BlockPos pos, ShapeContext context) {&para;<BR>      return this.collidable ? state.getOutlineShape(world, pos) : VoxelShapes.empty();&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public VoxelShape get</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=10731">V</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=10731">CameraColl</INS><SPAN TITLE="i=10741">is</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=10743">ual</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=10743">ion</INS><SPAN TITLE="i=10746">Shape(BlockState state, BlockView world, BlockPos pos, ShapeContext context) {&para;<BR>      return this.getCollisionShape(state, world, pos, context);&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public void randomTick(BlockState state, ServerWorld world, BlockPos pos, Random random) {&para;<BR>      this.scheduledTick(state, world, pos, random);&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public void scheduledTick(BlockState state, ServerWorld world, BlockPos pos, Random random) {&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public float calcBlockBreakingDelta(BlockState state, PlayerEntity player, BlockView world, BlockPos pos) {&para;<BR>      float f = state.getHardness(world, pos);&para;<BR>      if (f == -1.0F) {&para;<BR>         return 0.0F;&para;<BR>      } else {&para;<BR>         int i = player.</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=11440">isUsi</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=11440">ca</INS><SPAN TITLE="i=11442">n</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=11443">gEff</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=11443">Harv</INS><SPAN TITLE="i=11447">e</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=11448">c</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=11448">s</INS><SPAN TITLE="i=11449">t</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=11450">iveTool</DEL><SPAN TITLE="i=11450">(state) ? 30 : 100;&para;<BR>         return player.getBlockBreakingSpeed(state) / f / (float)i;&para;<BR>      }&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public void onStacksDropped(BlockState state, ServerWorld world, BlockPos pos, ItemStack stack) {&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public void onBlockBreakStart(BlockState state, World world, BlockPos pos, PlayerEntity player) {&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public int getWeakRedstonePower(BlockState state, BlockView world, BlockPos pos, Direction direction) {&para;<BR>      return 0;&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public void onEntityCollision(BlockState state, World world, BlockPos pos, Entity entity) {&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public int getStrongRedstonePower(BlockState state, BlockView world, BlockPos pos, Direction direction) {&para;<BR>      return 0;&para;<BR>   }&para;<BR>&para;<BR></SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=12202">   public final boolean hasBlockEntity() {&para;<BR>      return this instanceof BlockEntityProvider;&para;<BR>   }&para;<BR>&para;<BR></DEL><SPAN TITLE="i=12202">   public final Identifier getLootTableId() {&para;<BR>      if (this.lootTableId == null) {&para;<BR>         Identifier identifier = Registry.BLOCK.getId(this.asBlock());&para;<BR>         this.lootTableId = new Identifier(identifier.getNamespace(), "blocks/" + identifier.getPath());&para;<BR>      }&para;<BR>&para;<BR>      return this.lootTableId;&para;<BR>   }&para;<BR>&para;<BR>   @Deprecated&para;<BR>   public void onProjectileHit(World world, BlockState state, BlockHitResult hit, ProjectileEntity projectile) {&para;<BR>   }&para;<BR>&para;<BR>   public abstract Item asItem();&para;<BR>&para;<BR>   protected abstract Block asBlock();&para;<BR>&para;<BR>   public Ma</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=12729">terial</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=12729">p</INS><SPAN TITLE="i=12730">Color getDefaultMa</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=12748">terial</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=12748">p</INS><SPAN TITLE="i=12749">Color() {&para;<BR>      return (Ma</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=12775">terial</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=12775">p</INS><SPAN TITLE="i=12776">Color)this.settings.ma</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=12798">terial</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=12798">p</INS><SPAN TITLE="i=12799">Color</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=12804">Fact</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=12804">Pr</INS><SPAN TITLE="i=12806">o</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=12807">vide</INS><SPAN TITLE="i=12811">r</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=12812">y</DEL><SPAN TITLE="i=12812">.apply(this.asBlock().getDefaultState());&para;<BR>   }&para;<BR>&para;<BR>   static {&para;<BR>      </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=12878">FA</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=12878">DIRE</INS><SPAN TITLE="i=12882">C</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=12883">T</INS><SPAN TITLE="i=12884">I</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=12885">O</INS><SPAN TITLE="i=12886">N</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=12887">G</DEL><SPAN TITLE="i=12887">S = new Direction[]{Direction.WEST, Direction.EAST, Direction.NORTH, Direction.SOUTH, Direction.DOWN, Direction.UP};&para;<BR>   }&para;<BR>&para;<BR>   public interface TypedContextPredicate&lt;A&gt; {&para;<BR>      boolean test(BlockState state, BlockView world, BlockPos pos, A type);&para;<BR>   }&para;<BR>&para;<BR>   public interface ContextPredicate {&para;<BR>      boolean test(BlockState state, BlockView world, BlockPos pos);&para;<BR>   }&para;<BR>&para;<BR>   public abstract static class AbstractBlockState extends State&lt;Block, BlockState&gt; {&para;<BR>      private final int luminance;&para;<BR>      private final boolean hasSidedTransparency;&para;<BR>      private final boolean isAir;&para;<BR>      private final Material material;&para;<BR>      private final Ma</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=13521">terial</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=13521">p</INS><SPAN TITLE="i=13522">Color ma</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=13530">terial</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=13530">p</INS><SPAN TITLE="i=13531">Color;&para;<BR>      private final float hardness;&para;<BR>      private final boolean toolRequired;&para;<BR>      private final boolean opaque;&para;<BR>      private final AbstractBlock.ContextPredicate solidBlockPredicate;&para;<BR>      private final AbstractBlock.ContextPredicate suffocationPredicate;&para;<BR>      private final AbstractBlock.ContextPredicate blockVisionPredicate;&para;<BR>      private final AbstractBlock.ContextPredicate postProcessPredicate;&para;<BR>      private final AbstractBlock.ContextPredicate emissiveLightingPredicate;&para;<BR>      @Nullable&para;<BR>      protected AbstractBlock.AbstractBlockState.ShapeCache shapeCache;&para;<BR>&para;<BR>      protected AbstractBlockState(Block block, ImmutableMap&lt;Property&lt;?&gt;, Comparable&lt;?&gt;&gt; propertyMap, MapCodec&lt;BlockState&gt; </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=14233">mapC</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=14233">c</INS><SPAN TITLE="i=14234">odec) {&para;<BR>         super(block, propertyMap, </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=14277">mapC</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=14277">c</INS><SPAN TITLE="i=14278">odec);&para;<BR>         AbstractBlock.Settings settings = block.settings;&para;<BR>         this.luminance = settings.luminance.applyAsInt(this.asBlockState());&para;<BR>         this.hasSidedTransparency = block.hasSidedTransparency(this.asBlockState());&para;<BR>         this.isAir = settings.isAir;&para;<BR>         this.material = settings.material;&para;<BR>         this.ma</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=14606">terial</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=14606">p</INS><SPAN TITLE="i=14607">Color = (Ma</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=14618">terial</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=14618">p</INS><SPAN TITLE="i=14619">Color)settings.ma</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=14636">terial</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=14636">p</INS><SPAN TITLE="i=14637">Color</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=14642">Fact</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=14642">Pr</INS><SPAN TITLE="i=14644">o</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=14645">vide</INS><SPAN TITLE="i=14649">r</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=14650">y</DEL><SPAN TITLE="i=14650">.apply(this.asBlockState());&para;<BR>         this.hardness = settings.hardness;&para;<BR>         this.toolRequired = settings.toolRequired;&para;<BR>         this.opaque = settings.opaque;&para;<BR>         this.solidBlockPredicate = settings.solidBlockPredicate;&para;<BR>         this.suffocationPredicate = settings.suffocationPredicate;&para;<BR>         this.blockVisionPredicate = settings.blockVisionPredicate;&para;<BR>         this.postProcessPredicate = settings.postProcessPredicate;&para;<BR>         this.emissiveLightingPredicate = settings.emissiveLightingPredicate;&para;<BR>      }&para;<BR>&para;<BR>      public void initShapeCache() {&para;<BR>         if (!this.getBlock().hasDynamicBounds()) {&para;<BR>            this.shapeCache = new AbstractBlock.AbstractBlockState.ShapeCache(this.asBlockState());&para;<BR>         }&para;<BR>&para;<BR>      }&para;<BR>&para;<BR>      public Block getBlock() {&para;<BR>         return (Block)this.owner;&para;<BR>      }&para;<BR>&para;<BR>      public Material getMaterial() {&para;<BR>         return this.material;&para;<BR>      }&para;<BR>&para;<BR>      public boolean allowsSpawning(BlockView world, BlockPos pos, EntityType&lt;?&gt; type) {&para;<BR>         return this.getBlock().settings.allowsSpawningPredicate.test(this.asBlockState(), world, pos, type);&para;<BR>      }&para;<BR>&para;<BR>      public boolean isTranslucent(BlockView world, BlockPos pos) {&para;<BR>         return this.shapeCache != null ? this.shapeCache.translucent : this.getBlock().isTranslucent(this.asBlockState(), world, pos);&para;<BR>      }&para;<BR>&para;<BR>      public int getOpacity(BlockView world, BlockPos pos) {&para;<BR>         return this.shapeCache != null ? this.shapeCache.lightSubtracted : this.getBlock().getOpacity(this.asBlockState(), world, pos);&para;<BR>      }&para;<BR>&para;<BR>      public VoxelShape getCullingFace(BlockView world, BlockPos pos, Direction direction) {&para;<BR>         return this.shapeCache != null &amp;&amp; this.shapeCache.extrudedFaces != null ? this.shapeCache.extrudedFaces[direction.ordinal()] : VoxelShapes.extrudeFace(this.getCullingShape(world, pos), direction);&para;<BR>      }&para;<BR>&para;<BR>      public VoxelShape getCullingShape(BlockView world, BlockPos pos) {&para;<BR>         return this.getBlock().getCullingShape(this.asBlockState(), world, pos);&para;<BR>      }&para;<BR>&para;<BR>      public boolean exceedsCube() {&para;<BR>         return this.shapeCache == null || this.shapeCache.exceedsCube;&para;<BR>      }&para;<BR>&para;<BR>      public boolean hasSidedTransparency() {&para;<BR>         return this.hasSidedTransparency;&para;<BR>      }&para;<BR>&para;<BR>      /**&para;<BR>       * Returns the light level emitted by this block state.&para;<BR>       */&para;<BR>      public int getLuminance() {&para;<BR>         return this.luminance;&para;<BR>      }&para;<BR>&para;<BR>      public boolean isAir() {&para;<BR>         return this.isAir;&para;<BR>      }&para;<BR>&para;<BR>      public Ma</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=17092">terial</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=17092">p</INS><SPAN TITLE="i=17093">Color get</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=17102">Top</DEL><SPAN TITLE="i=17102">Ma</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=17104">terial</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=17104">p</INS><SPAN TITLE="i=17105">Color(BlockView world, BlockPos pos) {&para;<BR>         return this.ma</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=17167">terial</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=17167">p</INS><SPAN TITLE="i=17168">Color;&para;<BR>      }&para;<BR>&para;<BR>      public BlockState rotate(BlockRotation rotation) {&para;<BR>         return this.getBlock().rotate(this.asBlockState(), rotation);&para;<BR>      }&para;<BR>&para;<BR>      public BlockState mirror(BlockMirror mirror) {&para;<BR>         return this.getBlock().mirror(this.asBlockState(), mirror);&para;<BR>      }&para;<BR>&para;<BR>      public BlockRenderType getRenderType() {&para;<BR>         return this.getBlock().getRenderType(this.asBlockState());&para;<BR>      }&para;<BR>&para;<BR></SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=17576">      @Environment(EnvType.CLIENT)&para;<BR></DEL><SPAN TITLE="i=17576">      public boolean hasEmissiveLighting(BlockView world, BlockPos pos) {&para;<BR>         return this.emissiveLightingPredicate.test(this.asBlockState(), world, pos);&para;<BR>      }&para;<BR>&para;<BR></SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=17745">      @Environment(EnvType.CLIENT)&para;<BR></DEL><SPAN TITLE="i=17745">      public float getAmbientOcclusionLightLevel(BlockView world, BlockPos pos) {&para;<BR>         return this.getBlock().getAmbientOcclusionLightLevel(this.asBlockState(), world, pos);&para;<BR>      }&para;<BR>&para;<BR>      public boolean isSolidBlock(BlockView world, BlockPos pos) {&para;<BR>         return this.solidBlockPredicate.test(this.asBlockState(), world, pos);&para;<BR>      }&para;<BR>&para;<BR>      public boolean emitsRedstonePower() {&para;<BR>         return this.getBlock().emitsRedstonePower(this.asBlockState());&para;<BR>      }&para;<BR>&para;<BR>      public int getWeakRedstonePower(BlockView world, BlockPos pos, Direction direction) {&para;<BR>         return this.getBlock().getWeakRedstonePower(this.asBlockState(), world, pos, direction);&para;<BR>      }&para;<BR>&para;<BR>      public boolean hasComparatorOutput() {&para;<BR>         return this.getBlock().hasComparatorOutput(this.asBlockState());&para;<BR>      }&para;<BR>&para;<BR>      public int getComparatorOutput(World world, BlockPos pos) {&para;<BR>         return this.getBlock().getComparatorOutput(this.asBlockState(), world, pos);&para;<BR>      }&para;<BR>&para;<BR>      public float getHardness(BlockView world, BlockPos pos) {&para;<BR>         return this.hardness;&para;<BR>      }&para;<BR>&para;<BR>      public float calcBlockBreakingDelta(PlayerEntity player, BlockView world, BlockPos pos) {&para;<BR>         return this.getBlock().calcBlockBreakingDelta(this.asBlockState(), player, world, pos);&para;<BR>      }&para;<BR>&para;<BR>      public int getStrongRedstonePower(BlockView world, BlockPos pos, Direction direction) {&para;<BR>         return this.getBlock().getStrongRedstonePower(this.asBlockState(), world, pos, direction);&para;<BR>      }&para;<BR>&para;<BR>      public PistonBehavior getPistonBehavior() {&para;<BR>         return this.getBlock().getPistonBehavior(this.asBlockState());&para;<BR>      }&para;<BR>&para;<BR>      public boolean isOpaqueFullCube(BlockView world, BlockPos pos) {&para;<BR>         if (this.shapeCache != null) {&para;<BR>            return this.shapeCache.fullOpaque;&para;<BR>         } else {&para;<BR>            BlockState blockState = this.asBlockState();&para;<BR>            return blockState.isOpaque() ? Block.isShapeFullCube(blockState.getCullingShape(world, pos)) : false;&para;<BR>         }&para;<BR>      }&para;<BR>&para;<BR>      public boolean isOpaque() {&para;<BR>         return this.opaque;&para;<BR>      }&para;<BR>&para;<BR></SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=19781">      @Environment(EnvType.CLIENT)&para;<BR></DEL><SPAN TITLE="i=19781">      public boolean isSideInvisible(BlockState state, Direction direction) {&para;<BR>         return this.getBlock().isSideInvisible(this.asBlockState(), state, direction);&para;<BR>      }&para;<BR>&para;<BR>      public VoxelShape getOutlineShape(BlockView world, BlockPos pos) {&para;<BR>         return this.getOutlineShape(world, pos, ShapeContext.absent());&para;<BR>      }&para;<BR>&para;<BR>      public VoxelShape getOutlineShape(BlockView world, BlockPos pos, ShapeContext context) {&para;<BR>         return this.getBlock().getOutlineShape(this.asBlockState(), world, pos, context);&para;<BR>      }&para;<BR>&para;<BR>      public VoxelShape getCollisionShape(BlockView world, BlockPos pos) {&para;<BR>         return this.shapeCache != null ? this.shapeCache.collisionShape : this.getCollisionShape(world, pos, ShapeContext.absent());&para;<BR>      }&para;<BR>&para;<BR>      public VoxelShape getCollisionShape(BlockView world, BlockPos pos, ShapeContext context) {&para;<BR>         return this.getBlock().getCollisionShape(this.asBlockState(), world, pos, context);&para;<BR>      }&para;<BR>&para;<BR>      public VoxelShape getSidesShape(BlockView world, BlockPos pos) {&para;<BR>         return this.getBlock().getSidesShape(this.asBlockState(), world, pos);&para;<BR>      }&para;<BR>&para;<BR>      public VoxelShape get</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=20910">V</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=20910">CameraColl</INS><SPAN TITLE="i=20920">is</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=20922">ual</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=20922">ion</INS><SPAN TITLE="i=20925">Shape(BlockView world, BlockPos pos, ShapeContext context) {&para;<BR>         return this.getBlock().get</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=21021">V</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=21021">CameraColl</INS><SPAN TITLE="i=21031">is</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=21033">ual</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=21033">ion</INS><SPAN TITLE="i=21036">Shape(this.asBlockState(), world, pos, context);&para;<BR>      }&para;<BR>&para;<BR>      public VoxelShape getRaycastShape(BlockView world, BlockPos pos) {&para;<BR>         return this.getBlock().getRaycastShape(this.asBlockState(), world, pos);&para;<BR>      }&para;<BR>&para;<BR>      public final boolean hasSolidTopSurface(BlockView world, BlockPos pos, Entity entity) {&para;<BR>         return this.hasSolidTopSurface(world, pos, entity, Direction.UP);&para;<BR>      }&para;<BR>&para;<BR>      public final boolean hasSolidTopSurface(BlockView world, BlockPos pos, Entity entity, Direction direction) {&para;<BR>         return Block.isFaceFullSquare(this.getCollisionShape(world, pos, ShapeContext.of(entity)), direction);&para;<BR>      }&para;<BR>&para;<BR>      public Vec3d getModelOffset(BlockView world, BlockPos pos) {&para;<BR>         </SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=21748">Block block = this.getBlock();&para;<BR>         </INS><SPAN TITLE="i=21788">AbstractBlock.OffsetType offsetType = </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=21826">this.getB</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=21826">b</INS><SPAN TITLE="i=21827">lock</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=21831">()</DEL><SPAN TITLE="i=21831">.getOffsetType();&para;<BR>         if (offsetType == AbstractBlock.OffsetType.NONE) {&para;<BR>            return Vec3d.ZERO;&para;<BR>         } else {&para;<BR>            long l = MathHelper.hashCode(pos.getX(), 0, pos.getZ());&para;<BR>            </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=22039">r</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=22039">float f = block.g</INS><SPAN TITLE="i=22056">et</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=22058">MaxModelOffset();&para;<BR>            do</INS><SPAN TITLE="i=22090">u</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=22091">rn n</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=22091">bl</INS><SPAN TITLE="i=22093">e</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=22094">w</DEL><SPAN TITLE="i=22094"> </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=22095">V</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=22095">d = MathH</INS><SPAN TITLE="i=22104">e</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=22105">lper.</INS><SPAN TITLE="i=22110">c</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=22111">3d((</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=22111">lamp(((double)((float)(l &amp; 15L) / 15.0F) - 0.5D) * 0.5D, </INS><SPAN TITLE="i=22168">(double)(</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=22177">(</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=22177">-</INS><SPAN TITLE="i=22178">f</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=22179">loat</DEL><SPAN TITLE="i=22179">)</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=22180">, </INS><SPAN TITLE="i=22182">(</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=22183">doub</INS><SPAN TITLE="i=22187">l</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=22188">e)f);&para;<BR>      </INS><SPAN TITLE="i=22200"> </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=22201">&amp;</DEL><SPAN TITLE="i=22201"> </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=22202">15L)</DEL><SPAN TITLE="i=22202"> </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=22203">/</DEL><SPAN TITLE="i=22203"> </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=22204">15.0F)</DEL><SPAN TITLE="i=22204"> </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=22205">-</DEL><SPAN TITLE="i=22205"> </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=22206">0.5D)</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=22206">double</INS><SPAN TITLE="i=22212"> </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=22213">*</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=22213">e</INS><SPAN TITLE="i=22214"> </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=22215">0.5D,</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=22215">=</INS><SPAN TITLE="i=22216"> offsetType == AbstractBlock.OffsetType.XYZ ? ((double)((float)(l &gt;&gt; 4 &amp; 15L) / 15.0F) - 1.0D) * 0.2D : 0.0D</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=22324">,</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=22324">;&para;<BR>            double g =</INS><SPAN TITLE="i=22348"> </SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=22349">MathHelper.clamp(</INS><SPAN TITLE="i=22366">((double)((float)(l &gt;&gt; 8 &amp; 15L) / 15.0F) - 0.5D) * 0.5D</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=22421">, (double)(-f), (double)f);&para;<BR>            return new Vec3d(d, e, g</INS><SPAN TITLE="i=22485">);&para;<BR>         }&para;<BR>      }&para;<BR>&para;<BR>      public boolean onSyncedBlockEvent(World world, BlockPos pos, int type, int data) {&para;<BR>         return this.getBlock().onSyncedBlockEvent(this.asBlockState(), world, pos, type, data);&para;<BR>      }&para;<BR>&para;<BR>      public void neighborUpdate(World world, BlockPos pos, Block block, BlockPos posFrom, boolean notify) {&para;<BR>         this.getBlock().neighborUpdate(this.asBlockState(), world, pos, block, posFrom, notify);&para;<BR>      }&para;<BR>&para;<BR>      public final void updateNeighbors(WorldAccess world, BlockPos pos, int flags) {&para;<BR>         this.updateNeighbors(world, pos, flags, 512);&para;<BR>      }&para;<BR>&para;<BR>      public final void updateNeighbors(WorldAccess world, BlockPos pos, int flags, int maxUpdateDepth) {&para;<BR>         this.getBlock();&para;<BR>         BlockPos.Mutable mutable = new BlockPos.Mutable();&para;<BR>         Direction[] var6 = AbstractBlock.</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=23303">FA</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=23303">DIRE</INS><SPAN TITLE="i=23307">C</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=23308">T</INS><SPAN TITLE="i=23309">I</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=23310">O</INS><SPAN TITLE="i=23311">N</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=23312">G</DEL><SPAN TITLE="i=23312">S;&para;<BR>         int var7 = var6.length;&para;<BR>&para;<BR>         for(int var8 = 0; var8 &lt; var7; ++var8) {&para;<BR>            Direction direction = var6[var8];&para;<BR>            mutable.set(pos, </SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=23474">(Direction)</INS><SPAN TITLE="i=23485">direction);&para;<BR>            BlockState blockState = world.getBlockState(mutable);&para;<BR>            BlockState blockState2 = blockState.getStateForNeighborUpdate(direction.getOpposite(), this.asBlockState(), world, mutable, pos);&para;<BR>            Block.replace(blockState, blockState2, world, mutable, flags, maxUpdateDepth);&para;<BR>         }&para;<BR>&para;<BR>      }&para;<BR>&para;<BR>      public final void prepare(WorldAccess world, BlockPos pos, int flags) {&para;<BR>         this.prepare(world, pos, flags, 512);&para;<BR>      }&para;<BR>&para;<BR>      public void prepare(WorldAccess world, BlockPos pos, int flags, int maxUpdateDepth) {&para;<BR>         this.getBlock().prepare(this.asBlockState(), world, pos, flags, maxUpdateDepth);&para;<BR>      }&para;<BR>&para;<BR>      public void onBlockAdded(World world, BlockPos pos, BlockState state, boolean notify) {&para;<BR>         this.getBlock().onBlockAdded(this.asBlockState(), world, pos, state, notify);&para;<BR>      }&para;<BR>&para;<BR>      public void onStateReplaced(World world, BlockPos pos, BlockState state, boolean moved) {&para;<BR>         this.getBlock().onStateReplaced(this.asBlockState(), world, pos, state, moved);&para;<BR>      }&para;<BR>&para;<BR>      public void scheduledTick(ServerWorld world, BlockPos pos, Random random) {&para;<BR>         this.getBlock().scheduledTick(this.asBlockState(), world, pos, random);&para;<BR>      }&para;<BR>&para;<BR>      public void randomTick(ServerWorld world, BlockPos pos, Random random) {&para;<BR>         this.getBlock().randomTick(this.asBlockState(), world, pos, random);&para;<BR>      }&para;<BR>&para;<BR>      public void onEntityCollision(World world, BlockPos pos, Entity entity) {&para;<BR>         this.getBlock().onEntityCollision(this.asBlockState(), world, pos, entity);&para;<BR>      }&para;<BR>&para;<BR>      public void onStacksDropped(ServerWorld world, BlockPos pos, ItemStack stack) {&para;<BR>         this.getBlock().onStacksDropped(this.asBlockState(), world, pos, stack);&para;<BR>      }&para;<BR>&para;<BR>      public List&lt;ItemStack&gt; getDroppedStacks(LootContext.Builder builder) {&para;<BR>         return this.getBlock().getDroppedStacks(this.asBlockState(), builder);&para;<BR>      }&para;<BR>&para;<BR>      public ActionResult onUse(World world, PlayerEntity player, Hand hand, BlockHitResult hit) {&para;<BR>         return this.getBlock().onUse(this.asBlockState(), world, hit.getBlockPos(), player, hand, hit);&para;<BR>      }&para;<BR>&para;<BR>      public void onBlockBreakStart(World world, BlockPos pos, PlayerEntity player) {&para;<BR>         this.getBlock().onBlockBreakStart(this.asBlockState(), world, pos, player);&para;<BR>      }&para;<BR>&para;<BR>      public boolean shouldSuffocate(BlockView world, BlockPos pos) {&para;<BR>         return this.suffocationPredicate.test(this.asBlockState(), world, pos);&para;<BR>      }&para;<BR>&para;<BR></SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=25934">      @Environment(EnvType.CLIENT)&para;<BR></DEL><SPAN TITLE="i=25934">      public boolean shouldBlockVision(BlockView world, BlockPos pos) {&para;<BR>         return this.blockVisionPredicate.test(this.asBlockState(), world, pos);&para;<BR>      }&para;<BR>&para;<BR>      </SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=26102">/**&para;<BR>       * Gets the </INS><SPAN TITLE="i=26124">p</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=26125">u</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=26125">ossi</INS><SPAN TITLE="i=26129">bl</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=26131">ic</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=26131">y</INS><SPAN TITLE="i=26132"> </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=26133">B</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=26133">updated b</INS><SPAN TITLE="i=26142">lock</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=26146">S</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=26146"> s</INS><SPAN TITLE="i=26148">tate </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=26153">g</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=26153">of this block wh</INS><SPAN TITLE="i=26169">e</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=26170">tSt</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=26170">n </INS><SPAN TITLE="i=26172">a</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=26173">t</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=26173"> n</INS><SPAN TITLE="i=26175">e</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=26176">F</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=26176">ighb</INS><SPAN TITLE="i=26180">or</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=26182">Ne</DEL><SPAN TITLE="i=26182">i</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=26183">n</INS><SPAN TITLE="i=26184">g</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=26185">h</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=26185"> </INS><SPAN TITLE="i=26186">b</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=26187">l</INS><SPAN TITLE="i=26188">o</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=26189">rU</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=26189">ck is u</INS><SPAN TITLE="i=26196">pdate</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=26201">(D</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=26201">d.&para;<BR>       * &para;<BR>       * @return the new state of this block&para;<BR>       * &para;<BR>       * @param d</INS><SPAN TITLE="i=26286">irection </SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=26295">the </INS><SPAN TITLE="i=26299">direction</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=26308">,</DEL><SPAN TITLE="i=26308"> </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=26309">B</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=26309">from this b</INS><SPAN TITLE="i=26320">lock</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=26324"> to the neighbor&para;<BR>       * @param neighbor</INS><SPAN TITLE="i=26365">State </SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=26371">the </INS><SPAN TITLE="i=26375">state</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=26380">,</DEL><SPAN TITLE="i=26380"> </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=26381">W</DEL><SPAN TITLE="i=26381">o</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=26382">rl</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=26382">f the up</INS><SPAN TITLE="i=26390">d</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=26391">Acc</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=26391">at</INS><SPAN TITLE="i=26393">e</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=26394">ss</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=26394">d</INS><SPAN TITLE="i=26395"> </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=26396">w</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=26396">neighb</INS><SPAN TITLE="i=26402">or</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=26404">ld,</DEL><SPAN TITLE="i=26404"> </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=26405">B</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=26405">b</INS><SPAN TITLE="i=26406">lock</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=26410">Pos</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=26410">&para;<BR></INS><SPAN TITLE="i=26411"> </SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=26412">      * @</INS><SPAN TITLE="i=26421">p</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=26422">aram w</INS><SPAN TITLE="i=26428">o</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=26429">s,</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=26429">rld the world&para;<BR>       * @param pos the position of this</INS><SPAN TITLE="i=26483"> </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=26484">B</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=26484">b</INS><SPAN TITLE="i=26485">lock</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=26489">&para;<BR>       * @param neighbor</INS><SPAN TITLE="i=26514">Pos </SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=26518">the position o</INS><SPAN TITLE="i=26532">f</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=26533"> the neighbor block&para;<BR>       */&para;<BR>      public BlockState getStateForNeighborUpdate(Direction direction, BlockState neighborState, WorldAccess wo</INS><SPAN TITLE="i=26674">r</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=26675">ld, BlockPos pos, BlockPos neighb</INS><SPAN TITLE="i=26708">o</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=26709">m</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=26709">r</INS><SPAN TITLE="i=26710">Pos) {&para;<BR>         return this.getBlock().getStateForNeighborUpdate(this.asBlockState(), direction, </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=26807">s</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=26807">neighborS</INS><SPAN TITLE="i=26816">tate, world, pos, </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=26834">fr</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=26834">neighb</INS><SPAN TITLE="i=26840">o</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=26841">m</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=26841">r</INS><SPAN TITLE="i=26842">Pos);&para;<BR>      }&para;<BR>&para;<BR>      public boolean canPathfindThrough(BlockView world, BlockPos pos, NavigationType type) {&para;<BR>         return this.getBlock().canPathfindThrough(this.asBlockState(), world, pos, type);&para;<BR>      }&para;<BR>&para;<BR>      public boolean canReplace(ItemPlacementContext context) {&para;<BR>         return this.getBlock().canReplace(this.asBlockState(), context);&para;<BR>      }&para;<BR>&para;<BR>      public boolean canBucketPlace(Fluid fluid) {&para;<BR>         return this.getBlock().canBucketPlace(this.asBlockState(), fluid);&para;<BR>      }&para;<BR>&para;<BR>      public boolean canPlaceAt(WorldView world, BlockPos pos) {&para;<BR>         return this.getBlock().canPlaceAt(this.asBlockState(), world, pos);&para;<BR>      }&para;<BR>&para;<BR>      public boolean shouldPostProcess(BlockView world, BlockPos pos) {&para;<BR>         return this.postProcessPredicate.test(this.asBlockState(), world, pos);&para;<BR>      }&para;<BR>&para;<BR>      @Nullable&para;<BR>      public NamedScreenHandlerFactory createScreenHandlerFactory(World world, BlockPos pos) {&para;<BR>         return this.getBlock().createScreenHandlerFactory(this.asBlockState(), world, pos);&para;<BR>      }&para;<BR>&para;<BR>      public boolean isIn(Tag&lt;Block&gt; tag) {&para;<BR>         return t</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=27921">ag.contains(t</INS><SPAN TITLE="i=27934">his.getBlock()</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=27948">.isIn(tag</DEL><SPAN TITLE="i=27948">);&para;<BR>      }&para;<BR>&para;<BR>      public boolean </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=27981">method_27851</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=27981">isIn</INS><SPAN TITLE="i=27985">(Tag&lt;Block&gt; tag, Predicate&lt;AbstractBlock.AbstractBlockState&gt; predicate) {&para;<BR>         return this.</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=28080">isIn(ta</INS><SPAN TITLE="i=28087">g</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=28088">) &amp;&amp; pr</INS><SPAN TITLE="i=28095">e</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=28096">dica</INS><SPAN TITLE="i=28100">t</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=28101">e.test(this);&para;<BR>      }&para;<BR>&para;<BR>      public boolean has</INS><SPAN TITLE="i=28148">Block</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=28153">Entity</INS><SPAN TITLE="i=28159">()</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=28161"> {&para;<BR>         return this</INS><SPAN TITLE="i=28184">.</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=28185">getBlock() </INS><SPAN TITLE="i=28196">i</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=28197">n</INS><SPAN TITLE="i=28198">s</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=28199">I</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=28199">ta</INS><SPAN TITLE="i=28201">n</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=28202">(</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=28202">ceof BlockEn</INS><SPAN TITLE="i=28214">t</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=28215">ityProvider;&para;<BR>      }&para;<BR>&para;<BR>      @Null</INS><SPAN TITLE="i=28248">a</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=28249">ble&para;<BR>      public &lt;T extends BlockEntity&gt; BlockEntityTicker&lt;T&gt; </INS><SPAN TITLE="i=28311">g</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=28312">)</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=28312">etBlockEntityTicker(World world,</INS><SPAN TITLE="i=28344"> </SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=28345">&amp;&amp;</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=28345">BlockEntityType&lt;T&gt;</INS><SPAN TITLE="i=28363"> </SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=28364">blockEntityTy</INS><SPAN TITLE="i=28377">p</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=28378">e) {&para;<BR>         </INS><SPAN TITLE="i=28392">re</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=28394">d</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=28394">turn th</INS><SPAN TITLE="i=28401">i</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=28402">s.getBlo</INS><SPAN TITLE="i=28410">c</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=28411">k() inst</INS><SPAN TITLE="i=28419">a</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=28420">nceof BlockEntityProvider ? ((BlockEnti</INS><SPAN TITLE="i=28459">t</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=28460">yProvid</INS><SPAN TITLE="i=28467">e</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=28468">r)this</INS><SPAN TITLE="i=28474">.</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=28475">ge</INS><SPAN TITLE="i=28477">t</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=28478">Block()).g</INS><SPAN TITLE="i=28488">e</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=28489">s</DEL><SPAN TITLE="i=28489">t</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=28490">Ticker</INS><SPAN TITLE="i=28496">(</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=28497">world, </INS><SPAN TITLE="i=28504">this</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=28508">.asBlockState(), blockEntityType</INS><SPAN TITLE="i=28540">)</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=28541"> : null</INS><SPAN TITLE="i=28548">;&para;<BR>      }&para;<BR>&para;<BR>      public boolean isOf(Block block) {&para;<BR>         return this.getBlock()</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=28631">.is(</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=28631"> == </INS><SPAN TITLE="i=28635">block</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=28640">)</DEL><SPAN TITLE="i=28640">;&para;<BR>      }&para;<BR>&para;<BR>      public FluidState getFluidState() {&para;<BR>         return this.getBlock().getFluidState(this.asBlockState());&para;<BR>      }&para;<BR>&para;<BR>      public boolean hasRandomTicks() {&para;<BR>         return this.getBlock().hasRandomTicks(this.asBlockState());&para;<BR>      }&para;<BR>&para;<BR></SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=28888">      @Environment(EnvType.CLIENT)&para;<BR></DEL><SPAN TITLE="i=28888">      public long getRenderingSeed(BlockPos pos) {&para;<BR>         return this.getBlock().getRenderingSeed(this.asBlockState(), pos);&para;<BR>      }&para;<BR>&para;<BR>      public BlockSoundGroup getSoundGroup() {&para;<BR>         return this.getBlock().getSoundGroup(this.asBlockState());&para;<BR>      }&para;<BR>&para;<BR>      public void onProjectileHit(World world, BlockState state, BlockHitResult hit, ProjectileEntity projectile) {&para;<BR>         this.getBlock().onProjectileHit(world, state, hit, projectile);&para;<BR>      }&para;<BR>&para;<BR>      public boolean isSideSolidFullSquare(BlockView world, BlockPos pos, Direction direction) {&para;<BR>         return this.isSideSolid(world, pos, direction, SideShapeType.FULL);&para;<BR>      }&para;<BR>&para;<BR>      public boolean isSideSolid(BlockView world, BlockPos pos, Direction direction, SideShapeType shapeType) {&para;<BR>         return this.shapeCache != null ? this.shapeCache.isSideSolid(direction, shapeType) : shapeType.matches(this.asBlockState(), world, pos, direction);&para;<BR>      }&para;<BR>&para;<BR>      public boolean isFullCube(BlockView world, BlockPos pos) {&para;<BR>         return this.shapeCache != null ? this.shapeCache.isFullCube : Block.isShapeFullCube(this.getCollisionShape(world, pos));&para;<BR>      }&para;<BR>&para;<BR>      protected abstract BlockState asBlockState();&para;<BR>&para;<BR>      public boolean isToolRequired() {&para;<BR>         return this.toolRequired;&para;<BR>      }&para;<BR>&para;<BR>      static final class ShapeCache {&para;<BR>         private static final Direction[] DIRECTIONS = Direction.values();&para;<BR>         private static final int SHAPE_TYPE_LENGTH = SideShapeType.values().length;&para;<BR>         protected final boolean fullOpaque;&para;<BR>         private final boolean translucent;&para;<BR>         private final int lightSubtracted;&para;<BR>         @Nullable&para;<BR>         private final VoxelShape[] extrudedFaces;&para;<BR>         protected final VoxelShape collisionShape;&para;<BR>         protected final boolean exceedsCube;&para;<BR>         private final boolean[] solidSides;&para;<BR>         protected final boolean isFullCube;&para;<BR>&para;<BR>         private ShapeCache(BlockState state) {&para;<BR>            Block block = state.getBlock();&para;<BR>            this.fullOpaque = state.isOpaqueFullCube(EmptyBlockView.INSTANCE, BlockPos.ORIGIN);&para;<BR>            this.translucent = block.isTranslucent(state, EmptyBlockView.INSTANCE, BlockPos.ORIGIN);&para;<BR>            this.lightSubtracted = block.getOpacity(state, EmptyBlockView.INSTANCE, BlockPos.ORIGIN);&para;<BR>            int var5;&para;<BR>            if (!state.isOpaque()) {&para;<BR>               this.extrudedFaces = null;&para;<BR>            } else {&para;<BR>               this.extrudedFaces = new VoxelShape[DIRECTIONS.length];&para;<BR>               VoxelShape voxelShape = block.getCullingShape(state, EmptyBlockView.INSTANCE, BlockPos.ORIGIN);&para;<BR>               Direction[] var4 = DIRECTIONS;&para;<BR>               var5 = var4.length;&para;<BR>&para;<BR>               for(int var6 = 0; var6 &lt; var5; ++var6) {&para;<BR>                  Direction direction = var4[var6];&para;<BR>                  this.extrudedFaces[direction.ordinal()] = VoxelShapes.extrudeFace(voxelShape, direction);&para;<BR>               }&para;<BR>            }&para;<BR>&para;<BR>            this.collisionShape = block.getCollisionShape(state, EmptyBlockView.INSTANCE, BlockPos.ORIGIN, ShapeContext.absent());&para;<BR>            this.exceedsCube = Arrays.stream(Direction.Axis.values()).anyMatch((axis) -&gt; {&para;<BR>               return this.collisionShape.getMin(axis) &lt; 0.0D || this.collisionShape.getMax(axis) &gt; 1.0D;&para;<BR>            });&para;<BR>            this.solidSides = new boolean[DIRECTIONS.length * SHAPE_TYPE_LENGTH];&para;<BR>            Direction[] var11 = DIRECTIONS;&para;<BR>            int var12 = var11.length;&para;<BR>&para;<BR>            for(var5 = 0; var5 &lt; var12; ++var5) {&para;<BR>               Direction direction2 = var11[var5];&para;<BR>               SideShapeType[] var14 = SideShapeType.values();&para;<BR>               int var8 = var14.length;&para;<BR>&para;<BR>               for(int var9 = 0; var9 &lt; var8; ++var9) {&para;<BR>                  SideShapeType sideShapeType = var14[var9];&para;<BR>                  this.solidSides[indexSolidSide(direction2, sideShapeType)] = sideShapeType.matches(state, EmptyBlockView.INSTANCE, BlockPos.ORIGIN, direction2);&para;<BR>               }&para;<BR>            }&para;<BR>&para;<BR>            this.isFullCube = Block.isShapeFullCube(state.getCollisionShape(EmptyBlockView.INSTANCE, BlockPos.ORIGIN));&para;<BR>         }&para;<BR>&para;<BR>         public boolean isSideSolid(Direction direction, SideShapeType shapeType) {&para;<BR>            return this.solidSides[indexSolidSide(direction, shapeType)];&para;<BR>         }&para;<BR>&para;<BR>         private static int indexSolidSide(Direction direction, SideShapeType shapeType) {&para;<BR>            return direction.ordinal() * SHAPE_TYPE_LENGTH + shapeType.ordinal();&para;<BR>         }&para;<BR>      }&para;<BR>   }&para;<BR>&para;<BR>   public static class Settings {&para;<BR>      private Material material;&para;<BR>      private Function&lt;BlockState, Ma</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=33393">terial</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=33393">p</INS><SPAN TITLE="i=33394">Color&gt; ma</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=33403">terial</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=33403">p</INS><SPAN TITLE="i=33404">Color</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=33409">Fact</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=33409">Pr</INS><SPAN TITLE="i=33411">o</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=33412">vide</INS><SPAN TITLE="i=33416">r</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=33417">y</DEL><SPAN TITLE="i=33417">;&para;<BR>      private boolean collidable;&para;<BR>      private BlockSoundGroup soundGroup;&para;<BR>      private ToIntFunction&lt;BlockState&gt; luminance;&para;<BR>      private float resistance;&para;<BR>      private float hardness;&para;<BR>      private boolean toolRequired;&para;<BR>      private boolean randomTicks;&para;<BR>      private float slipperiness;&para;<BR>      private float velocityMultiplier;&para;<BR>      private float jumpVelocityMultiplier;&para;<BR>      private Identifier lootTableId;&para;<BR>      private boolean opaque;&para;<BR>      private boolean isAir;&para;<BR>      private AbstractBlock.TypedContextPredicate&lt;EntityType&lt;?&gt;&gt; allowsSpawningPredicate;&para;<BR>      private AbstractBlock.ContextPredicate solidBlockPredicate;&para;<BR>      private AbstractBlock.ContextPredicate suffocationPredicate;&para;<BR>      private AbstractBlock.ContextPredicate blockVisionPredicate;&para;<BR>      private AbstractBlock.ContextPredicate postProcessPredicate;&para;<BR>      private AbstractBlock.ContextPredicate emissiveLightingPredicate;&para;<BR>      private boolean dynamicBounds;&para;<BR>&para;<BR>      private Settings(Material material, Ma</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=34405">terial</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=34405">p</INS><SPAN TITLE="i=34406">Color ma</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=34414">terial</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=34414">p</INS><SPAN TITLE="i=34415">Color</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=34420">Fact</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=34420">Pr</INS><SPAN TITLE="i=34422">o</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=34423">vide</INS><SPAN TITLE="i=34427">r</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=34428">y</DEL><SPAN TITLE="i=34428">) {&para;<BR>         this(material, (state) -&gt; {&para;<BR>            return ma</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=34490">terial</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=34490">p</INS><SPAN TITLE="i=34491">Color</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=34496">Fact</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=34496">Pr</INS><SPAN TITLE="i=34498">o</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=34499">vide</INS><SPAN TITLE="i=34503">r</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=34504">y</DEL><SPAN TITLE="i=34504">;&para;<BR>         });&para;<BR>      }&para;<BR>&para;<BR>      private Settings(Material material, Function&lt;BlockState, Ma</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=34593">terial</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=34593">p</INS><SPAN TITLE="i=34594">Color&gt; ma</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=34603">terial</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=34603">p</INS><SPAN TITLE="i=34604">Color</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=34609">Fact</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=34609">Pr</INS><SPAN TITLE="i=34611">o</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=34612">vide</INS><SPAN TITLE="i=34616">r</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=34617">y</DEL><SPAN TITLE="i=34617">) {&para;<BR>         this.collidable = true;&para;<BR>         this.soundGroup = BlockSoundGroup.STONE;&para;<BR>         this.luminance = (state) -&gt; {&para;<BR>            return 0;&para;<BR>         };&para;<BR>         this.slipperiness = 0.6F;&para;<BR>         this.velocityMultiplier = 1.0F;&para;<BR>         this.jumpVelocityMultiplier = 1.0F;&para;<BR>         this.opaque = true;&para;<BR>         this.allowsSpawningPredicate = (state, world, pos, type) -&gt; {&para;<BR>            return state.isSideSolidFullSquare(world, pos, Direction.UP) &amp;&amp; state.getLuminance() &lt; 14;&para;<BR>         };&para;<BR>         this.solidBlockPredicate = (state, world, pos) -&gt; {&para;<BR>            return state.getMaterial().blocksLight() &amp;&amp; state.isFullCube(world, pos);&para;<BR>         };&para;<BR>         this.suffocationPredicate = (state, world, pos) -&gt; {&para;<BR>            return this.material.blocksMovement() &amp;&amp; state.isFullCube(world, pos);&para;<BR>         };&para;<BR>         this.blockVisionPredicate = this.suffocationPredicate;&para;<BR>         this.postProcessPredicate = (state, world, pos) -&gt; {&para;<BR>            return false;&para;<BR>         };&para;<BR>         this.emissiveLightingPredicate = (state, world, pos) -&gt; {&para;<BR>            return false;&para;<BR>         };&para;<BR>         this.material = material;&para;<BR>         this.ma</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=35749">terial</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=35749">p</INS><SPAN TITLE="i=35750">Color</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=35755">Fact</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=35755">Pr</INS><SPAN TITLE="i=35757">o</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=35758">vide</INS><SPAN TITLE="i=35762">r</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=35763">y</DEL><SPAN TITLE="i=35763"> = ma</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=35768">terial</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=35768">p</INS><SPAN TITLE="i=35769">Color</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=35774">Fact</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=35774">Pr</INS><SPAN TITLE="i=35776">o</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=35777">vide</INS><SPAN TITLE="i=35781">r</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=35782">y</DEL><SPAN TITLE="i=35782">;&para;<BR>      }&para;<BR>&para;<BR>      public static AbstractBlock.Settings of(Material material) {&para;<BR>         return of(material, material.getColor());&para;<BR>      }&para;<BR>&para;<BR>      public static AbstractBlock.Settings of(Material material, DyeColor color) {&para;<BR>         return of(material, color.getMa</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=36043">terial</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=36043">p</INS><SPAN TITLE="i=36044">Color());&para;<BR>      }&para;<BR>&para;<BR>      public static AbstractBlock.Settings of(Material material, Ma</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=36130">terial</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=36130">p</INS><SPAN TITLE="i=36131">Color color) {&para;<BR>         return new AbstractBlock.Settings(material, color);&para;<BR>      }&para;<BR>&para;<BR>      public static AbstractBlock.Settings of(Material material, Function&lt;BlockState, Ma</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=36304">terial</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=36304">p</INS><SPAN TITLE="i=36305">Color&gt; ma</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=36314">terial</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=36314">p</INS><SPAN TITLE="i=36315">Color) {&para;<BR>         return new AbstractBlock.Settings(material, ma</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=36379">terial</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=36379">p</INS><SPAN TITLE="i=36380">Color);&para;<BR>      }&para;<BR>&para;<BR>      public static AbstractBlock.Settings copy(AbstractBlock block) {&para;<BR>         AbstractBlock.Settings settings = new AbstractBlock.Settings(block.material, block.settings.ma</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=36571">terial</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=36571">p</INS><SPAN TITLE="i=36572">Color</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=36577">Fact</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=36577">Pr</INS><SPAN TITLE="i=36579">o</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=36580">vide</INS><SPAN TITLE="i=36584">r</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=36585">y</DEL><SPAN TITLE="i=36585">);&para;<BR>         settings.material = block.settings.material;&para;<BR>         settings.hardness = block.settings.hardness;&para;<BR>         settings.resistance = block.settings.resistance;&para;<BR>         settings.collidable = block.settings.collidable;&para;<BR>         settings.randomTicks = block.settings.randomTicks;&para;<BR>         settings.luminance = block.settings.luminance;&para;<BR>         settings.ma</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=36948">terial</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=36948">p</INS><SPAN TITLE="i=36949">Color</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=36954">Fact</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=36954">Pr</INS><SPAN TITLE="i=36956">o</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=36957">vide</INS><SPAN TITLE="i=36961">r</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=36962">y</DEL><SPAN TITLE="i=36962"> = block.settings.ma</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=36982">terial</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=36982">p</INS><SPAN TITLE="i=36983">Color</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=36988">Fact</DEL><INS STYLE="background:#E6FFE6;" TITLE="i=36988">Pr</INS><SPAN TITLE="i=36990">o</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=36991">vide</INS><SPAN TITLE="i=36995">r</SPAN><DEL STYLE="background:#FFE6E6;" TITLE="i=36996">y</DEL><SPAN TITLE="i=36996">;&para;<BR>         settings.soundGroup = block.settings.soundGroup;&para;<BR>         settings.slipperiness = block.settings.slipperiness;&para;<BR>         settings.velocityMultiplier = block.settings.velocityMultiplier;&para;<BR>         settings.dynamicBounds = block.settings.dynamicBounds;&para;<BR>         settings.opaque = block.settings.opaque;&para;<BR>         settings.isAir = block.settings.isAir;&para;<BR>         settings.toolRequired = block.settings.toolRequired;&para;<BR>         return settings;&para;<BR>      }&para;<BR>&para;<BR>      /**&para;<BR>       * Specifies that a block should have no collision bounds.&para;<BR>       * &para;<BR>       * &lt;p&gt;This also marks a block as non-opaque.&para;<BR>       */&para;<BR>      public AbstractBlock.Settings noCollision() {&para;<BR>         this.collidable = false;&para;<BR>         this.opaque = false;&para;<BR>         return this;&para;<BR>      }&para;<BR>&para;<BR>      /**&para;<BR>       * Specifies that a block should be non-opaque and light should be allowed to pass through.&para;<BR>       */&para;<BR>      public AbstractBlock.Settings nonOpaque() {&para;<BR>         this.opaque = false;&para;<BR>         return this;&para;<BR>      }&para;<BR>&para;<BR>      public AbstractBlock.Settings slipperiness(float slipperiness) {&para;<BR>         this.slipperiness = slipperiness;&para;<BR>         return this;&para;<BR>      }&para;<BR>&para;<BR>      public AbstractBlock.Settings velocityMultiplier(float velocityMultiplier) {&para;<BR>         this.velocityMultiplier = velocityMultiplier;&para;<BR>         return this;&para;<BR>      }&para;<BR>&para;<BR>      public AbstractBlock.Settings jumpVelocityMultiplier(float jumpVelocityMultiplier) {&para;<BR>         this.jumpVelocityMultiplier = jumpVelocityMultiplier;&para;<BR>         return this;&para;<BR>      }&para;<BR>&para;<BR>      public AbstractBlock.Settings sounds(BlockSoundGroup soundGroup) {&para;<BR>         this.soundGroup = soundGroup;&para;<BR>         return this;&para;<BR>      }&para;<BR>&para;<BR>      /**&para;<BR>       * Specifies the light level emitted by a block.&para;<BR>       * &para;<BR>       * @param luminance a per block state light level, with values between 0 and 15&para;<BR>       */&para;<BR>      public AbstractBlock.Settings luminance(ToIntFunction&lt;BlockState&gt; luminance) {&para;<BR>         this.luminance = luminance;&para;<BR>         return this;&para;<BR>      }&para;<BR>&para;<BR>      public AbstractBlock.Settings strength(float hardness, float resistance) {&para;<BR>         this.hardness = hardness;&para;<BR>         this.resistance = Math.max(0.0F, resistance);&para;<BR>         return this;&para;<BR>      }&para;<BR>&para;<BR>      /**&para;<BR>       * Specifies that a block is broken instantly.&para;<BR>       */&para;<BR>      public AbstractBlock.Settings breakInstantly() {&para;<BR>         return this.strength(0.0F);&para;<BR>      }&para;<BR>&para;<BR>      public AbstractBlock.Settings strength(float strength) {&para;<BR>         this.strength(strength, strength);&para;<BR>         return this;&para;<BR>      }&para;<BR>&para;<BR>      public AbstractBlock.Settings ticksRandomly() {&para;<BR>         this.randomTicks = true;&para;<BR>         return this;&para;<BR>      }&para;<BR>&para;<BR>      /**&para;<BR>       * Specifies that a block's collision bounds can dynamically resize.&para;<BR>       * By default, block collision bounds are cached for performance.&para;<BR>       * By invoking this method, the game will not cache the block collision bounds and instead calculate the collision bounds when needed.&para;<BR>       */&para;<BR>      public AbstractBlock.Settings dynamicBounds() {&para;<BR>         this.dynamicBounds = true;&para;<BR>         return this;&para;<BR>      }&para;<BR>&para;<BR>      /**&para;<BR>       * Specifies that a block drops nothing when broken.&para;<BR>       */&para;<BR>      public AbstractBlock.Settings dropsNothing() {&para;<BR>         this.lootTableId = LootTables.EMPTY;&para;<BR>         return this;&para;<BR>      }&para;<BR>&para;<BR>      /**&para;<BR>       * Specifies that a block should drop the same items as a provided block.&para;<BR>       * &para;<BR>       * @param source the block to copy item drops from&para;<BR>       */&para;<BR>      public AbstractBlock.Settings dropsLike(Block source) {&para;<BR>         this.lootTableId = source.getLootTableId();&para;<BR>         return this;&para;<BR>      }&para;<BR>&para;<BR>      public AbstractBlock.Settings air() {&para;<BR>         this.isAir = true;&para;<BR>         return this;&para;<BR>      }&para;<BR>&para;<BR>      /**&para;<BR>       * Specifies logic that calculates whether an entity can spawn on a block.&para;<BR>       * &para;<BR>       * @param predicate the predicate used to calculate whether an entity can spawn on this block&para;<BR>       */&para;<BR>      public AbstractBlock.Settings allowsSpawning(AbstractBlock.TypedContextPredicate&lt;EntityType&lt;?&gt;&gt; predicate) {&para;<BR>         this.allowsSpawningPredicate = predicate;&para;<BR>         return this;&para;<BR>      }&para;<BR>&para;<BR>      public AbstractBlock.Settings solidBlock(AbstractBlock.ContextPredicate predicate) {&para;<BR>         this.solidBlockPredicate = predicate;&para;<BR>         return this;&para;<BR>      }&para;<BR>&para;<BR>      /**&para;<BR>       * Specifies logic that calculates whether an entity should suffocate if inside of a block.&para;<BR>       */&para;<BR>      public AbstractBlock.Settings suffocates(AbstractBlock.ContextPredicate predicate) {&para;<BR>         this.suffocationPredicate = predicate;&para;<BR>         return this;&para;<BR>      }&para;<BR>&para;<BR>      public AbstractBlock.Settings blockVision(AbstractBlock.ContextPredicate predicate) {&para;<BR>         this.blockVisionPredicate = predicate;&para;<BR>         return this;&para;<BR>      }&para;<BR>&para;<BR>      public AbstractBlock.Settings postProcess(AbstractBlock.ContextPredicate predicate) {&para;<BR>         this.postProcessPredicate = predicate;&para;<BR>         return this;&para;<BR>      }&para;<BR>&para;<BR>      public AbstractBlock.Settings emissiveLighting(AbstractBlock.ContextPredicate predicate) {&para;<BR>         this.emissiveLightingPredicate = predicate;&para;<BR>         return this;&para;<BR>      }&para;<BR>&para;<BR>      public AbstractBlock.Settings requiresTool() {&para;<BR>         this.toolRequired = true</SPAN><INS STYLE="background:#E6FFE6;" TITLE="i=42100">;&para;<BR>         return this;&para;<BR>      }&para;<BR>&para;<BR>      public AbstractBlock.Settings mapColor(MapColor color) {&para;<BR>         this.mapColorProvider = (state) -&gt; {&para;<BR>            return color;&para;<BR>         }</INS><SPAN TITLE="i=42278">;&para;<BR>         return this;&para;<BR>      }&para;<BR>   }&para;<BR>&para;<BR>   public static enum OffsetType {&para;<BR>      NONE,&para;<BR>      XZ,&para;<BR>      XYZ;&para;<BR>   }&para;<BR>}&para;<BR></SPAN>
